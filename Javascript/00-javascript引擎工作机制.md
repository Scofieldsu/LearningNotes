
---

JavaScript引擎是一个执行JavaScript代码的程序或解释器。

实现了JavaScript引擎的一个热门项目列表:

- **V8** — 开源，由Google开发，用C++编写的

- **Rhino** — 由Mozilla基金所管理，开源，完全用Java开发

- **SpiderMonkey** —第一个JavaScript引擎，最早用在Netscape Navigator上，现在用在**Firefox**上。

- JavaScriptCore — 开源，以Nitro销售，由苹果公司为**Safari**开发

- **KJS** —KDE的引擎最初由Harri Porten开发，用于KDE项目的Konqueror浏览器

- **Chakra (JScript9)** — **Internet Explorer**

- **Chakra (JavaScript)** — **Microsoft Edge**

- **Nashorn**— 开源为OpenJDK的一部分，由Oracle的Java语言和工具组开发

- **JerryScript** —  是用于物联网的轻量级引擎

---

### V8曾经有两个编译器

  在V8 的5.9版（今年早些时候发布）出现之前，V8引擎用了两个编译器：

- **full-codegen** – 一个简单而超快的编译器，可以生成简单而相对较慢的机器码。

- **Crankshaft** – 一个更复杂（即时）的优化的编译器，可以生成高度优化的代码。

### V8引擎还在内部使用多个线程：

- 主线程执行我们想让它干的活：获取代码，编译然后执行它
- 还有一个单独的线程用于编译，这样在主线程继续执行的同时，单独的线程能同时在优化代码
- 一个Profiler线程，用于让运行时知道哪些方法花了大量时间，这样Crankshaft就可以对它们进行优化
- 几个线程用于处理垃圾收集器清扫

> 第一次执行JavaScript代码时，V8会利用full-codegen直接将解析的JavaScript翻译为机器码，而无需任何转换。这就让它能非常快地开始执行机器码。请注意，由于V8不会使用中间字节码表示，这样就无需解释器。

>代码运行了一段时间后，Profiler线程已经收集了足够的数据来判断应该优化哪个方法。

>接下来，Crankshaft优化从另一个线程中开始。它将JavaScript抽象语法树翻译为称为Hydrogen的高级静态单赋值（SSA）表示，并尝试优化Hydrogen图。大多数优化都是在这一级完成的。

---
### V8工作机制

- 内联：内联是用被调用的函数的函数体替换调用位置（调用函数所在的代码行）的过程。

- 隐藏类：

``` javascript
function Point(x, y) {
    this.x = x;
    this.y = y;
}
 
var p1 = new Point(1, 2);
p1.a = 5;
p1.b = 6;
 
var p2 = new Point(3, 4);
p2.b = 7;
p2.a = 8;

对于p1，首先是添加属性a，然后是属性b。不过，对于p2，先是给b赋值，然后才是a。因此，由于转换路径不同，p1和p2最终会有不同的隐藏类。在这种情况下，以相同的顺序初始化动态属性要更好，这样隐藏类才可以被重用。
```

- 内联缓存

- 编译到机器码

- 垃圾回收

- Ignition 和 TurboFan
---
### 如何编写优化的JavaScript

- 对象属性的顺序：始终以相同的顺序实例化对象属性，以便可以共享隐藏类和随后优化的代码。

- 动态属性：在实例化后向对象添加属性会强制修改隐藏类，减慢为之前的隐藏类优化了的方法。所以应该在构造函数中指定对象的所有属性。

- 方法：重复执行相同方法的代码将比只执行一次的代码（由于内联缓存）运行得快。

- 数组：避免键不是增量数字的稀疏数组。元素不全的稀疏数组是一个哈希表，而访问这种数组中的元素更昂贵。另外，尽量避免预分配大数组。最好随着发展而增长。最后，不要删除数组中的元素。它会让键变得稀疏。

- 标记值：V8用32位表示对象和数字。它用一位来判断是对象（flag = 1）还是整数（flag=0）（这个整数称为SMI（SMall Integer，小整数），因为它是31位）。然后，如果一个数值大于31位，V8将会对数字装箱，将其转化为 double，并创建一个新对象将该数字放在里面。所以要尽可能使用31位有符号数字，从而避免昂贵的转换为JS对象的装箱操作。